#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
09_gerar_kml_mapa.py
====================
Gera arquivo KML para Google My Maps com indicadores consolidados por padaria.

Este script consolida as an√°lises de sentimento por padaria e gera um arquivo
KML que pode ser importado no Google My Maps para visualiza√ß√£o geogr√°fica.

Indicadores exibidos no popup:
- Score de sentimento (escala -1 a +1)
- Ranking entre todas as padarias
- Nota m√©dia do Google
- % Sentimentos por categoria (com far√≥is coloridos)
- Taxa de resposta do dono
- % de avaliadores Local Guides
- Top evid√™ncias positivas e negativas

Requisitos:
    pip install pandas openpyxl tqdm

Uso:
    python 09_gerar_kml_mapa.py --input dataset_com_coords.xlsx --output padarias.kml

Autor: Filipe Silva
Data: 2025
"""

import pandas as pd
import json
import argparse
import sys

# Tqdm √© opcional
try:
    from tqdm import tqdm
except ImportError:
    def tqdm(iterable, **kwargs):
        return iterable


# =============================================================================
# CONFIGURA√á√ïES
# =============================================================================

SENTIMENTO_SCORE = {
    'positivo': 1.0, 
    'neutro': 0.0, 
    'negativo': -1.0
}

CATEGORIA_LABEL = {
    'comida': 'Comida', 
    'atendimento': 'Atend.', 
    'ambiente': 'Ambiente', 
    'preco': 'Pre√ßo', 
    'problemas': 'Probl.'
}

ORDEM_CATEGORIAS = ['comida', 'atendimento', 'ambiente', 'preco', 'problemas']


# =============================================================================
# FUN√á√ïES DE CONSOLIDA√á√ÉO
# =============================================================================

def parsear_llm_json(json_str) -> list:
    """
    Parseia o campo llm_analise_json.
    
    Args:
        json_str: String JSON ou dict com an√°lises
        
    Returns:
        Lista de an√°lises
    """
    if pd.isna(json_str):
        return []
    try:
        data = json.loads(json_str) if isinstance(json_str, str) else json_str
        return data.get('analises', [])
    except:
        return []


def consolidar_padaria(df_padaria: pd.DataFrame) -> dict:
    """
    Consolida indicadores para uma padaria.
    
    Args:
        df_padaria: DataFrame filtrado para uma padaria
        
    Returns:
        Dicion√°rio com indicadores consolidados
    """
    
    # Extrair todas as an√°lises
    todas_analises = []
    for _, row in df_padaria.iterrows():
        for analise in parsear_llm_json(row.get('llm_analise_json')):
            todas_analises.append({
                'categoria': analise.get('categoria', '').lower(),
                'sentimento': analise.get('sentimento', '').lower(),
                'evidencia': analise.get('evidencia', '')
            })
    
    if not todas_analises:
        return None
    
    # 1. Sentimentos por categoria
    sentimentos_por_categoria = {}
    for cat in set(a['categoria'] for a in todas_analises if a['categoria']):
        cat_analises = [a for a in todas_analises if a['categoria'] == cat]
        total = len(cat_analises)
        if total > 0:
            sentimentos_por_categoria[cat] = {
                'positivo': round(sum(1 for a in cat_analises if a['sentimento'] == 'positivo') / total * 100, 1),
                'neutro': round(sum(1 for a in cat_analises if a['sentimento'] == 'neutro') / total * 100, 1),
                'negativo': round(sum(1 for a in cat_analises if a['sentimento'] == 'negativo') / total * 100, 1),
                'total': total
            }
    
    # 2. Top evid√™ncias (3 positivas + 3 negativas)
    positivas = [a for a in todas_analises if a['sentimento'] == 'positivo' and a['evidencia']][:3]
    negativas = [a for a in todas_analises if a['sentimento'] == 'negativo' and a['evidencia']][:3]
    top_evidencias = positivas + negativas
    
    # 3. Score m√©dio
    scores = [SENTIMENTO_SCORE.get(a['sentimento'], 0) for a in todas_analises]
    score_medio = sum(scores) / len(scores) if scores else 0
    
    # 4. Indicadores adicionais
    total_reviews = len(df_padaria)
    
    # Rating Google
    rating_google = None
    if 'rating' in df_padaria.columns:
        rating_google = df_padaria['rating'].mean()
        if pd.notna(rating_google):
            rating_google = round(rating_google, 2)
        else:
            rating_google = None
    
    # Taxa de resposta do dono
    respostas = 0
    if 'response_from_owner_text' in df_padaria.columns:
        respostas = df_padaria['response_from_owner_text'].notna().sum()
    taxa_resposta = round(respostas / total_reviews * 100, 1) if total_reviews > 0 else 0
    
    # % Local Guides
    local_guides = 0
    if 'is_local_guide' in df_padaria.columns:
        local_guides = df_padaria['is_local_guide'].sum()
    pct_local_guides = round(local_guides / total_reviews * 100, 1) if total_reviews > 0 else 0
    
    # Faixa de pre√ßo
    price_range = None
    if 'price_range' in df_padaria.columns:
        pr = df_padaria['price_range'].iloc[0]
        if pd.notna(pr) and str(pr).strip() and str(pr) != 'nan':
            price_range = str(pr)
    
    return {
        'sentimentos_por_categoria': sentimentos_por_categoria,
        'top_evidencias': [(e['evidencia'], e['sentimento']) for e in top_evidencias],
        'score_medio': round(score_medio, 3),
        'total_reviews': total_reviews,
        'total_analises': len(todas_analises),
        'rating_google': rating_google,
        'taxa_resposta': taxa_resposta,
        'pct_local_guides': pct_local_guides,
        'price_range': price_range
    }


# =============================================================================
# GERA√á√ÉO DE FAR√ìIS E DESCRI√á√ÉO
# =============================================================================

def farol(valor: float, tipo: str = 'score') -> str:
    """
    Retorna emoji de farol colorido baseado no valor.
    
    Args:
        valor: Valor num√©rico
        tipo: Tipo de farol ('score', 'positivo', 'negativo')
        
    Returns:
        Emoji do farol (üü¢, üü°, üî¥)
    """
    if tipo == 'score':
        if valor >= 0.2:
            return 'üü¢'
        elif valor >= -0.2:
            return 'üü°'
        else:
            return 'üî¥'
    elif tipo == 'positivo':
        if valor >= 60:
            return 'üü¢'
        elif valor >= 40:
            return 'üü°'
        else:
            return 'üî¥'
    elif tipo == 'negativo':
        if valor >= 30:
            return 'üî¥'  # Ruim ter muito negativo
        elif valor >= 15:
            return 'üü°'
        else:
            return 'üü¢'  # Bom ter pouco negativo
    return '‚ö™'


def gerar_descricao(indicadores: dict, place_name: str, ranking: int = None, total_padarias: int = None) -> str:
    """
    Gera descri√ß√£o em texto formatado para popup do My Maps.
    
    Args:
        indicadores: Dicion√°rio com indicadores consolidados
        place_name: Nome da padaria
        ranking: Posi√ß√£o no ranking
        total_padarias: Total de padarias
        
    Returns:
        String formatada para o popup
    """
    
    score = indicadores.get('score_medio', 0)
    
    # Status
    if score >= 0.2:
        status = 'BOM'
    elif score >= -0.2:
        status = 'REGULAR'
    else:
        status = 'RUIM'
    
    # Cabe√ßalho com nome da padaria
    desc = f'''‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
ü•ñ {place_name.upper()}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìä RESUMO GERAL
{farol(score, 'score')} Score Sentimento: {score:+.2f} ({status})
'''
    
    # Ranking (se dispon√≠vel)
    if ranking and total_padarias:
        desc += f"üèÜ Ranking: #{ranking} de {total_padarias}\n"
    
    # Nota Google
    if indicadores.get('rating_google'):
        desc += f"‚≠ê Nota Google: {indicadores['rating_google']}\n"
    
    desc += f"üìù Avalia√ß√µes: {indicadores.get('total_reviews', 0):,}\n"
    desc += f"üí¨ Men√ß√µes analisadas: {indicadores.get('total_analises', 0):,}\n"
    
    # Indicadores extras
    if indicadores.get('taxa_resposta', 0) > 0:
        desc += f"‚Ü©Ô∏è Taxa resposta dono: {indicadores['taxa_resposta']:.0f}%\n"
    if indicadores.get('pct_local_guides', 0) > 0:
        desc += f"üèÖ Local Guides: {indicadores['pct_local_guides']:.0f}%\n"
    if indicadores.get('price_range'):
        desc += f"üí∞ Faixa de pre√ßo: {indicadores['price_range']}\n"

    # Tabela de sentimentos
    desc += '''
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìà SENTIMENTOS POR CATEGORIA
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
            POS    NEU    NEG
'''
    
    f_neu = '‚ö™' # Emoji para Neutro
    
    for cat in ORDEM_CATEGORIAS:
        if cat in indicadores.get('sentimentos_por_categoria', {}):
            d = indicadores['sentimentos_por_categoria'][cat]
            f_pos = farol(d['positivo'], 'positivo')
            f_neg = farol(d['negativo'], 'negativo')
            label = CATEGORIA_LABEL.get(cat, cat.title())
            
            # Formata√ß√£o ajustada com f_neu para alinhamento
            desc += f"{label:8} {f_pos}{d['positivo']:4.0f}%  {f_neu}{d['neutro']:4.0f}%  {f_neg}{d['negativo']:4.0f}%\n"

    # Top evid√™ncias
    desc += '''
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üí¨ O QUE DIZEM
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
'''
    
    for evidencia, sentimento in indicadores.get('top_evidencias', [])[:6]:
        emoji = '‚úÖ' if sentimento == 'positivo' else ('‚ùå' if sentimento == 'negativo' else '‚ûñ')
        ev = (evidencia[:50] + '...') if len(evidencia) > 50 else evidencia
        desc += f"{emoji} {ev}\n"
    
    return desc


# =============================================================================
# GERA√á√ÉO DO KML
# =============================================================================

def gerar_kml(input_file: str, output_file: str) -> None:
    """
    Gera arquivo KML para Google My Maps.
    
    Args:
        input_file: Arquivo Excel com coordenadas
        output_file: Arquivo KML de sa√≠da
    """
    
    print(f"\nüìÇ Carregando {input_file}...")
    try:
        df = pd.read_excel(input_file)
    except FileNotFoundError:
        print(f"‚ùå Erro: Arquivo '{input_file}' n√£o encontrado.")
        sys.exit(1)
    
    # Verificar coordenadas
    if 'lat' not in df.columns or 'lng' not in df.columns:
        print("‚ùå Dataset n√£o possui colunas 'lat' e 'lng'!")
        print("   Execute primeiro o script de extra√ß√£o de coordenadas.")
        return
    
    total_padarias = df['place_id'].nunique()
    print(f"   {len(df):,} reviews | {total_padarias} padarias")
    
    # Calcular ranking por score
    print("\nüìä Calculando rankings...")
    rankings = {}
    scores_padarias = []
    
    for place_id in df['place_id'].unique():
        df_padaria = df[df['place_id'] == place_id]
        indicadores = consolidar_padaria(df_padaria)
        if indicadores:
            scores_padarias.append((place_id, indicadores['score_medio']))
    
    # Ordenar por score (maior = melhor ranking)
    scores_padarias.sort(key=lambda x: x[1], reverse=True)
    for i, (place_id, _) in enumerate(scores_padarias, 1):
        rankings[place_id] = i
    
    # In√≠cio do KML
    kml_content = '''<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
<name>Padarias SP - Analise de Sentimentos</name>
<description>Mapa de sentimentos das padarias paulistanas</description>

<Style id="verde">
  <IconStyle><scale>1.3</scale><Icon><href>http://maps.google.com/mapfiles/kml/paddle/grn-circle.png</href></Icon></IconStyle>
</Style>
<Style id="amarelo">
  <IconStyle><scale>1.3</scale><Icon><href>http://maps.google.com/mapfiles/kml/paddle/ylw-circle.png</href></Icon></IconStyle>
</Style>
<Style id="vermelho">
  <IconStyle><scale>1.3</scale><Icon><href>http://maps.google.com/mapfiles/kml/paddle/red-circle.png</href></Icon></IconStyle>
</Style>
'''
    
    placemarks = []
    sem_coords = 0
    
    for place_id in tqdm(df['place_id'].unique(), desc="Gerando KML"):
        df_padaria = df[df['place_id'] == place_id]
        
        lat = df_padaria['lat'].iloc[0]
        lng = df_padaria['lng'].iloc[0]
        place_name = str(df_padaria['place_name'].iloc[0])
        
        if pd.isna(lat) or pd.isna(lng):
            sem_coords += 1
            continue
        
        indicadores = consolidar_padaria(df_padaria)
        if not indicadores:
            continue
        
        score = indicadores.get('score_medio', 0)
        ranking = rankings.get(place_id)
        
        # Determinar estilo (cor do pin)
        if score >= 0.2:
            style_id = 'verde'
        elif score >= -0.2:
            style_id = 'amarelo'
        else:
            style_id = 'vermelho'
        
        # Escapar nome para XML
        place_name_safe = place_name.replace('&', '&').replace('<', '<').replace('>', '>')
        
        # Gerar descri√ß√£o
        descricao = gerar_descricao(indicadores, place_name, ranking, total_padarias)
        
        # Criar placemark
        placemark = f'''
<Placemark>
  <name>{place_name_safe}</name>
  <description><![CDATA[{descricao}]]></description>
  <styleUrl>#{style_id}</styleUrl>
  <Point>
    <coordinates>{lng},{lat},0</coordinates>
  </Point>
</Placemark>'''
        
        placemarks.append(placemark)
    
    # Finalizar KML
    kml_content += '\n'.join(placemarks)
    kml_content += '''
</Document>
</kml>'''
    
    # Salvar
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(kml_content)
        
        print(f"\n‚úÖ KML gerado: {output_file}")
        print(f"   üü¢ Padarias no mapa: {len(placemarks)}")
        print(f"   ‚ö†Ô∏è  Sem coordenadas: {sem_coords}")
        
        # Estat√≠sticas por cor
        verdes = sum(1 for p in placemarks if '#verde' in p)
        amarelos = sum(1 for p in placemarks if '#amarelo' in p)
        vermelhos = sum(1 for p in placemarks if '#vermelho' in p)
        print(f"\nüìä Distribui√ß√£o:")
        print(f"   üü¢ Verde (score ‚â• +0.2): {verdes}")
        print(f"   üü° Amarelo (-0.2 a +0.2): {amarelos}")
        print(f"   üî¥ Vermelho (score < -0.2): {vermelhos}")
        
        print(f"\nüìç Como usar:")
        print(f"   1. Acesse https://www.google.com/maps/d/")
        print(f"   2. Clique em 'Criar novo mapa'")
        print(f"   3. Clique em 'Importar' ‚Üí selecione {output_file}")
        print(f"   4. Clique nas padarias para ver os indicadores!")
        
    except Exception as e:
        print(f"‚ùå Erro ao salvar arquivo: {e}")


# =============================================================================
# MAIN
# =============================================================================

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Gera KML para Google My Maps com indicadores de sentimento'
    )
    parser.add_argument(
        '--input', '-i', 
        required=True, 
        help='Arquivo Excel com coordenadas'
    )
    parser.add_argument(
        '--output', '-o', 
        default='padarias_mapa.kml', 
        help='Arquivo KML de sa√≠da (default: padarias_mapa.kml)'
    )
    
    args = parser.parse_args()
    gerar_kml(args.input, args.output)
